name: Coverage

on:
  pull_request:
    branches: [main]

permissions:
  contents: read
  pull-requests: write

jobs:
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: "1.3.9"

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build
        run: bun run build

      - name: Run tests with coverage
        run: |
          cd packages/core
          bun test --coverage --coverage-reporter=lcov --coverage-reporter=text 2>&1 | tee /tmp/coverage.log
          cp coverage/lcov.info /tmp/lcov.info

      - name: Parse coverage
        id: coverage
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Parse the text coverage output
            const coverageLog = fs.readFileSync('/tmp/coverage.log', 'utf8');
            const lcov = fs.readFileSync('/tmp/lcov.info', 'utf8');

            // Extract the summary line ("All files" row)
            const lines = coverageLog.split('\n');
            const allFilesLine = lines.find(l => l.includes('All files'));

            let totalFuncs = 'â€“';
            let totalLines = 'â€“';
            if (allFilesLine) {
              const nums = allFilesLine.match(/[\d.]+/g);
              if (nums && nums.length >= 2) {
                totalFuncs = nums[0];
                totalLines = nums[1];
              }
            }

            // Parse per-file coverage from the table
            const tableRows = [];
            const tableRegex = /^ (.+?)\s+\|\s+([\d.]+)\s+\|\s+([\d.]+)\s+\|(.*)?$/;
            for (const line of lines) {
              const m = line.match(tableRegex);
              if (m && !m[1].includes('File') && !m[1].includes('All files') && !m[1].includes('---')) {
                const file = m[1].trim();
                const funcs = parseFloat(m[2]);
                const lns = parseFloat(m[3]);
                const uncovered = (m[4] || '').trim();
                tableRows.push({ file, funcs, lns, uncovered });
              }
            }

            // Parse lcov for total hit/found counts
            let linesFound = 0;
            let linesHit = 0;
            let funcsFound = 0;
            let funcsHit = 0;
            for (const l of lcov.split('\n')) {
              if (l.startsWith('LF:')) linesFound += parseInt(l.slice(3));
              if (l.startsWith('LH:')) linesHit += parseInt(l.slice(3));
              if (l.startsWith('FNF:')) funcsFound += parseInt(l.slice(4));
              if (l.startsWith('FNH:')) funcsHit += parseInt(l.slice(4));
            }

            // Build the comment
            const linePct = linesFound > 0 ? ((linesHit / linesFound) * 100).toFixed(2) : '0';
            const funcPct = funcsFound > 0 ? ((funcsHit / funcsFound) * 100).toFixed(2) : '0';

            function badge(pct) {
              const n = parseFloat(pct);
              if (n >= 90) return 'ðŸŸ¢';
              if (n >= 70) return 'ðŸŸ¡';
              return 'ðŸ”´';
            }

            const body = [
              `## Coverage Report`,
              ``,
              `| Metric | Coverage | |`,
              `|--------|----------|---|`,
              `| **Lines** | ${linePct}% (${linesHit}/${linesFound}) | ${badge(linePct)} |`,
              `| **Functions** | ${funcPct}% (${funcsHit}/${funcsFound}) | ${badge(funcPct)} |`,
              ``,
            ];

            // Per-file breakdown
            if (tableRows.length > 0) {
              body.push(
                `<details>`,
                `<summary>Per-file breakdown (${tableRows.length} files)</summary>`,
                ``,
                `| File | Funcs | Lines | Uncovered |`,
                `|------|-------|-------|-----------|`,
              );
              for (const r of tableRows) {
                const fIcon = r.funcs >= 90 ? 'ðŸŸ¢' : r.funcs >= 70 ? 'ðŸŸ¡' : 'ðŸ”´';
                const lIcon = r.lns >= 90 ? 'ðŸŸ¢' : r.lns >= 70 ? 'ðŸŸ¡' : 'ðŸ”´';
                const uncov = r.uncovered ? `\`${r.uncovered}\`` : '';
                body.push(`| \`${r.file}\` | ${fIcon} ${r.funcs}% | ${lIcon} ${r.lns}% | ${uncov} |`);
              }
              body.push(``, `</details>`, ``);
            }

            // Files needing attention
            const lowCoverage = tableRows.filter(r => r.lns < 80);
            if (lowCoverage.length > 0) {
              body.push(`### Files needing attention`, ``);
              for (const r of lowCoverage) {
                body.push(`- **\`${r.file}\`** â€” ${r.lns}% line coverage${r.uncovered ? ` (uncovered: \`${r.uncovered}\`)` : ''}`);
              }
              body.push(``);
            }

            body.push(`*Run: [${context.runId}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})*`);

            // Find and update existing comment, or create new one
            const marker = '## Coverage Report';
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existing = comments.find(c =>
              c.user?.login === 'github-actions[bot]' && c.body?.includes(marker)
            );

            const commentBody = body.join('\n');

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: commentBody,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody,
              });
            }
